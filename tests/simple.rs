use std :: { io :: { self , BufReader , Read } , fs :: File } ; use source_span :: Position ; use utf8_decode :: UnsafeDecoder ; use chom :: gen ; use chom_ir :: eval ; lazy_static :: lazy_static ! { static ref GRAMMAR : chom :: mono :: OwnedGrammar = { let file = File :: open ("tests/simple.chom") . unwrap () ; let input = BufReader :: new (file) ; let metrics = source_span :: DefaultMetrics :: with_tab_stop (4) ; let utf8_input = UnsafeDecoder :: new (input . bytes ()) ; let buffer = source_span :: SourceBuffer :: new (utf8_input , Position :: default () , metrics) ; match chom :: parse_and_compile (& buffer , metrics) { Ok (grammar) => grammar , Err (e) => panic ! ("error") } } ; static ref CONTEXT : chom :: gen :: Context < 'static , 'static > = { let config = chom :: gen :: Config { locate : true } ; match gen :: context_from_grammar (config , GRAMMAR . mono () , & ["glue"] , & ["ast"] , & ["lexer"] , & ["parser"] ,) { Ok (context) => context , Err (e) => { panic ! ("error") } } } ; } # [test] fn add2 () -> io :: Result < () > { let context = & CONTEXT ; let phrase = "1 + 2" ; let target_ty = "expr" ; let expected = "expr.add(expr.term(term(int(1))), term(int(2)))" ; let mut source = phrase . chars () . map (| c | Ok (c)) ; let mut eval = eval :: Evaluator :: new (context . ir_context ()) ; let target_ty_expr = eval . context () . parse_ty_expr (& target_ty) . expect ("invalid target type expr") . expect ("target type not found") ; let lexer = eval . instanciate_lexer (& mut source) . expect ("no lexer") ; let parser = eval . context () . parsers_for (& target_ty_expr) . next () . expect ("no parser defined for target type") ; match eval . parse (parser , lexer) { Ok (result) => { match result { Ok (value) => { match eval . debug_format (value) { Ok (result) => { assert_eq ! (result , expected) ; Ok (()) } Err (e) => panic ! ("failed while formatting with: {}" , e) } } , Err (e) => panic ! ("failed with: {}" , e . as_ref () . name ()) } } , Err (e) => { panic ! ("fatal error during parsing: {}" , e) } } } # [test] fn add3 () -> io :: Result < () > { let context = & CONTEXT ; let phrase = "1 + 2 + 3" ; let target_ty = "expr" ; let expected = "expr.add(expr.add(expr.term(term(int(1))), term(int(2))), term(int(3)))" ; let mut source = phrase . chars () . map (| c | Ok (c)) ; let mut eval = eval :: Evaluator :: new (context . ir_context ()) ; let target_ty_expr = eval . context () . parse_ty_expr (& target_ty) . expect ("invalid target type expr") . expect ("target type not found") ; let lexer = eval . instanciate_lexer (& mut source) . expect ("no lexer") ; let parser = eval . context () . parsers_for (& target_ty_expr) . next () . expect ("no parser defined for target type") ; match eval . parse (parser , lexer) { Ok (result) => { match result { Ok (value) => { match eval . debug_format (value) { Ok (result) => { assert_eq ! (result , expected) ; Ok (()) } Err (e) => panic ! ("failed while formatting with: {}" , e) } } , Err (e) => panic ! ("failed with: {}" , e . as_ref () . name ()) } } , Err (e) => { panic ! ("fatal error during parsing: {}" , e) } } }