enum Error { UnexpectedToken (crate :: lexer :: Token) , UnexpectedEof } pub fn parse_term < L : :: std :: iter :: Iterator < Item = :: source_span :: Loc < crate :: lexer :: Token > > > (lexer : L) -> :: std :: result :: Result < crate :: ast :: Term , Error > { use crate :: lexer as lexer ; pub enum NonTerminal { Term (crate :: ast :: Term) } pub enum Item { Terminal (lexer :: Token) , NonTerminal (NonTerminal) } let mut stack = Vec :: new () ; let mut non_terminal = None ; let mut current_pos = :: source_span :: Position :: default () ; let mut state = 1u32 ; loop { state = match state { 1u32 => { match non_terminal { Some (nt) => { match nt { _ => unreachable ! () } } , None => { match token . as_ref () { Some (lexer :: Token :: Integer (value)) => { stack . push ((Item :: Terminal (lexer :: Token :: Integer (value)) , state)) ; 2u32 } Some (unexpected) => { let (token , span) = unexpected . into_raw_parts () ; return Err (Loc :: new (Error :: UnexpectedToken (token) , span)) } , None => return Err (Loc :: new (UnexpectedEof , current_pos . into ())) } } } } , 2u32 => { let (a0 , next_state) = if let lexer :: Token :: Integer (value) = stack . pop () { value } else { unreachable ! () } ; non_terminal = Some (NonTerminal :: Term (crate :: ast :: Term :: Int (a0))) ; next_state } } } } pub fn parse_expr < L : :: std :: iter :: Iterator < Item = :: source_span :: Loc < crate :: lexer :: Token > > > (lexer : L) -> :: std :: result :: Result < crate :: ast :: Expr , Error > { use crate :: lexer as lexer ; pub enum NonTerminal { Expr (crate :: ast :: Expr) , Term (crate :: ast :: Term) } pub enum Item { Terminal (lexer :: Token) , NonTerminal (NonTerminal) } let mut stack = Vec :: new () ; let mut non_terminal = None ; let mut current_pos = :: source_span :: Position :: default () ; let mut state = 0u32 ; loop { state = match state { 0u32 => { match non_terminal { Some (nt) => { match nt { NonTerminal :: Expr (value) => { stack . push ((Item :: NonTerminal (NonTerminal :: Expr (value)) , state)) ; 3u32 } , NonTerminal :: Term (value) => { stack . push ((Item :: NonTerminal (NonTerminal :: Term (value)) , state)) ; 4u32 } _ => unreachable ! () } } , None => { match token . as_ref () { Some (lexer :: Token :: Integer (value)) => { stack . push ((Item :: Terminal (lexer :: Token :: Integer (value)) , state)) ; 2u32 } Some (unexpected) => { let (token , span) = unexpected . into_raw_parts () ; return Err (Loc :: new (Error :: UnexpectedToken (token) , span)) } , None => return Err (Loc :: new (UnexpectedEof , current_pos . into ())) } } } } , 4u32 => { let (a0 , next_state) = if let NonTerminal :: Term (value) = stack . pop () { value } else { unreachable ! () } ; non_terminal = Some (NonTerminal :: Expr (crate :: ast :: Expr :: Term (a0))) ; next_state } , 3u32 => { match non_terminal { Some (nt) => { match nt { _ => unreachable ! () } } , None => { match token . as_ref () { Some (lexer :: Token :: Plus (value)) => { stack . push ((Item :: Terminal (lexer :: Token :: Plus (value)) , state)) ; 5u32 } Some (unexpected) => { let (token , span) = unexpected . into_raw_parts () ; return Err (Loc :: new (Error :: UnexpectedToken (token) , span)) } , None => return Err (Loc :: new (UnexpectedEof , current_pos . into ())) } } } } , 5u32 => { match non_terminal { Some (nt) => { match nt { NonTerminal :: Term (value) => { stack . push ((Item :: NonTerminal (NonTerminal :: Term (value)) , state)) ; 6u32 } _ => unreachable ! () } } , None => { match token . as_ref () { Some (lexer :: Token :: Integer (value)) => { stack . push ((Item :: Terminal (lexer :: Token :: Integer (value)) , state)) ; 2u32 } Some (unexpected) => { let (token , span) = unexpected . into_raw_parts () ; return Err (Loc :: new (Error :: UnexpectedToken (token) , span)) } , None => return Err (Loc :: new (UnexpectedEof , current_pos . into ())) } } } } , 6u32 => { let (a2 , _) = if let NonTerminal :: Term (value) = stack . pop () { value } else { unreachable ! () } ; ; let (a1 , _) = if let lexer :: Token :: Plus (value) = stack . pop () { value } else { unreachable ! () } ; ; let (a0 , next_state) = if let NonTerminal :: Expr (value) = stack . pop () { value } else { unreachable ! () } ; non_terminal = Some (NonTerminal :: Expr (crate :: ast :: Expr :: Add (a0 , a1 , a2))) ; next_state } , 2u32 => { let (a0 , next_state) = if let lexer :: Token :: Integer (value) = stack . pop () { value } else { unreachable ! () } ; non_terminal = Some (NonTerminal :: Term (crate :: ast :: Term :: Int (a0))) ; next_state } } } }